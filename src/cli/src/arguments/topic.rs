use clap::{Command, Arg, ArgAction};

pub fn cmd() -> Command {
    Command::new("topic")
        .about("Various topic subcommands")
        .aliases(&["t", "top"])
        .subcommand_required(true)
        .arg_required_else_help(true)
        .subcommand(
            Command::new("echo")
            .about("Print messages from topic to screen")
            .aliases(["e", "cat"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to echo (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_daemon")
                .long("no-daemon")
                .aliases(&["no_daemon"])
                .help("Don't spawn or use a running daemon")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("qos_profile")
                .long("qos-profile")
                .aliases(&["qos_profile", "qos"])
                .value_name("QOS_PROFILE")
                .num_args(1)
                .help("QoS preset profile to publish")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_depth")
                .long("qos-depth")
                .aliases(&["qos_depth", "depth"])
                .value_name("QOS_DEPTH")
                .num_args(1)
                .help("Queue size setting (overrides profile)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_history")
                .long("qos-history")
                .aliases(&["qos_history", "history"])
                .value_name("QOS_HISTORY")
                .num_args(1)
                .help("History of samples setting (overrides profile, default: keep_last)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_reliability")
                .long("qos-reliability")
                .aliases(&["qos_reliability", "reliability"])
                .value_name("QOS_RELIABILITY")
                .num_args(1)
                .help("QoS reliability setting (overrides profile, default: reliable)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_durability")
                .long("qos-durability")
                .aliases(&["qos_durability", "durability"])
                .value_name("QOS_DURABILITY")
                .num_args(1)
                .help("QoS durability setting (overrides profile, default: transient_local)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("csv")
                .long("csv")
                .help("Output fields separated by commas (for plotting)")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("field")
                .long("field")
                .value_name("FIELD")
                .num_args(1)
                .help("Echo selected field of a message")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("full_length")
                .short('f')
                .long("full-length")
                .aliases(&["full_length", "full"])
                .help("Output all elements for arrays, bytes, and long strings")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("truncate_length")
                .short('l')
                .long("truncate-length")
                .aliases(&["truncate_length", "truncate"])
                .value_name("TRUNCATE_LENGTH")
                .num_args(1)
                .help("Length to truncate arrays/strings to (default: 128)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("no_arr")
                .long("no-arr")
                .aliases(&["no_arr", "noarr"])
                .help("Don't print array fields")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_str")
                .long("no-str")
                .aliases(&["no_str", "nostr"])
                .help("Don't print string fields")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("flow_style")
                .long("flow-style")
                .aliases(&["flow_style", "flow"])
                .help("Print collections in block style (not in csv)")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_lost_messages")
                .long("no-lost-messages")
                .aliases(&["no_lost_messages", "nolost"])
                .help("Don't report lost messages")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("raw")
                .long("raw")
                .help("Echo raw binary representation")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("once")
                .long("once")
                .help("Print first message and exit")
                .action(ArgAction::SetTrue)
            )
        )
        .subcommand(
            Command::new("hz")
            .about("Display publishing rate of topic")
            .aliases(["h", "rate"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to monitor (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("window")
                .short('w')
                .long("window")
                .aliases(&["win"])
                .value_name("WINDOW")
                .num_args(1)
                .help("Window size for rate calculation (default: 10000)")
                .action(ArgAction::Append)
                .default_missing_value("10000")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("filter")
                .long("filter")
                .aliases(&["regex"])
                .value_name("EXPR")
                .help("Filter messages by Python expression")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("wall_time")
                .long("wall-time")
                .aliases(&["wall_time", "wall"])
                .help("Calculate rate using wall time (useful when clock is not published)")
                .action(ArgAction::SetTrue)
            )                 
        )
        .subcommand(
            Command::new("info")
            .about("Print information about a topic")
            .aliases(["i", "show"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to get info (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_daemon")
                .long("no-daemon")
                .aliases(&["no_daemon"])
                .help("Don't spawn or use a running daemon")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("verbose")
                .short('v')
                .long("verbose")
                .action(ArgAction::SetTrue)
                .help("Print detailed information about nodes, namespaces, topic types...")
            )                  
        )
        .subcommand(
            Command::new("list")
            .about("Output a list of available topics")
            .aliases(["l", "ls"])
            .arg(
                Arg::new("show_types")
                .short('t')
                .long("show-types")
                .aliases(&["show_types", "types"])
                .help("Additionally show the topic type")
                .action(ArgAction::SetTrue)
                .conflicts_with("count_topics")
            )
            .arg(
                Arg::new("count_topics")
                .short('c')
                .long("count-topics")
                .aliases(&["count_topics", "count"])
                .help("Only display the number of topics discovered")
                .action(ArgAction::SetTrue)
                .conflicts_with("show_types")
            )
            .arg(
                Arg::new("include_hidden_topics")
                .long("include-hidden-topics")
                .short('a')
                .aliases(&["include_hidden_topics", "all"])
                .visible_aliases(&["all"])
                .help("Consider hidden topics as well")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_daemon")
                .long("no-daemon")
                .aliases(&["no_daemon"])
                .help("Don't spawn or use a running daemon")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
        )
        .subcommand(
            Command::new("pub")
            .about("Publish a message to a topic")
            .aliases(["p", "publish"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to publish to (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("message_type")
                .help("Type of the ROS message (e.g. 'std_msgs/msg/String')")
                .required(true)
                .value_name("MESSAGE_TYPE")
            )
            .arg(
                Arg::new("values")
                .help("Values to fill the message with in YAML format (e.g. 'data: Hello World')")
                .required(true)
                .value_name("VALUES")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("rate")
                .short('r')
                .long("rate")
                .value_name("RATE")
                .num_args(1)
                .help("Publishing rate in Hz (default: 1)")
                .action(ArgAction::Append)
                .default_missing_value("1")
            )
            .arg(
                Arg::new("print")
                .short('p')
                .long("print")
                .value_name("PRINT")
                .num_args(1)
                .help("Print every N-th message (default: 1)")
                .action(ArgAction::Append)
                .default_missing_value("1")
            )
            .arg(
                Arg::new("once")
                .long("once")
                .short('1')
                .help("Publish one message and exit")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("times")
                .short('t')
                .long("times")
                .value_name("TIMES")
                .num_args(1)
                .help("Publish this many times and exit")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("wait_matching_subscriptions")
                .long("wait-matching-subscriptions")
                .aliases(&["wait_matching_subscriptions", "wait"])
                .value_name("WAIT_MATCHING_SUBS")
                .num_args(1)
                .help("Wait for specified matching subscriptions")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("keep_alive")
                .long("keep-alive")
                .aliases(&["keep_alive", "keepalive"])
                .value_name("KEEP_ALIVE")
                .num_args(1)
                .help("Keep node alive N sec after last message (default: 0.1)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("node_name")
                .short('n')
                .long("node-name")
                .aliases(&["node_name", "node"])
                .value_name("NODE_NAME")
                .num_args(1)
                .help("Name of publishing node")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_profile")
                .long("qos-profile")
                .aliases(&["qos_profile", "profile"])
                .value_name("QOS_PROFILE")
                .num_args(1)
                .help("QoS preset profile to publish")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_depth")
                .long("qos-depth")
                .aliases(&["qos_depth", "depth"])
                .value_name("QOS_DEPTH")
                .num_args(1)
                .help("Queue size setting (overrides profile)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_history")
                .long("qos-history")
                .aliases(&["qos_history", "history"])
                .value_name("QOS_HISTORY")
                .num_args(1)
                .help("History of samples setting (overrides profile, default: keep_last)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_reliability")
                .long("qos-reliability")
                .aliases(&["qos_reliability", "reliability"])
                .value_name("QOS_RELIABILITY")
                .num_args(1)
                .help("QoS reliability setting (overrides profile, default: reliable)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("qos_durability")
                .long("qos-durability")
                .aliases(&["qos_durability", "durability"])
                .value_name("QOS_DURABILITY")
                .num_args(1)
                .help("QoS durability setting (overrides profile, default: transient_local)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not used)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
        )
        .subcommand(
            Command::new("kind")
            .about("Print a topic's type/kind")
            .aliases(["k", "type"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to get type (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_daemon")
                .long("no-daemon")
                .aliases(&["no_daemon"])
                .help("Don't spawn or use a running daemon")
                .action(ArgAction::SetTrue)
            )
        )
        .subcommand(
            Command::new("bw")
            .about("Display bandwidth used by topic")
            .aliases(["b", "bandwidth"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to get bandwidth (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("window")
                .short('w')
                .long("window")
                .aliases(&["win"])
                .value_name("WINDOW")
                .num_args(1)
                .help("Window size for rate calculation (default: 10000)")
                .action(ArgAction::Append)
                .default_missing_value("10000")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not used)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
        )
        .subcommand(
            Command::new("find")
            .about("Output a list of available topics of a given type")
            .aliases(["f", "lookup", "search"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_type")
                .help("Name of the ROS topic type to filter for (e.g. 'std_msg/msg/String')")
                .required(true)
                .value_name("TOPIC_TYPE")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not in use)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("no_daemon")
                .long("no-daemon")
                .aliases(&["no_daemon"])
                .help("Don't spawn or use a running daemon")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("count_topics")
                .short('c')
                .long("count-topics")
                .aliases(&["count_topics", "count"])
                .help("Only display the number of topics discovered")
                .action(ArgAction::SetTrue)
            )
            .arg(
                Arg::new("include_hidden_topics")
                .long("include-hidden-topics")
                .short('a')
                .aliases(&["include_hidden_topics", "all"])
                .visible_aliases(&["all"])
                .help("Consider hidden topics as well")
                .action(ArgAction::SetTrue)
            )
        )
        .subcommand(
            Command::new("delay")
            .about("Display delay of topic from timestamp in header")
            .aliases(["d", "latency"])
            .arg_required_else_help(true)
            .arg(
                Arg::new("topic_name")
                .help("Name of the ROS topic to get bandwidth (e.g. '/chatter')")
                .required(true)
                .value_name("TOPIC_NAME")
            )
            .arg(
                Arg::new("window")
                .short('w')
                .long("window")
                .aliases(&["win"])
                .value_name("WINDOW")
                .num_args(1)
                .help("Window size for rate calculation (default: 10000)")
                .action(ArgAction::Append)
                .default_missing_value("10000")
            )
            .arg(
                Arg::new("spin_time")
                .long("spin-time")
                .aliases(&["spin_time", "spin"])
                .value_name("SPIN_TIME")
                .num_args(1)
                .help("Spin time for discovery (if daemon not used)")
                .action(ArgAction::Append)
            )
            .arg(
                Arg::new("use_sim_time")
                .short('s')
                .long("use-sim-time")
                .aliases(&["use_sim_time", "use_simtime", "sim"])
                .help("Enable ROS simulation time")
                .action(ArgAction::SetTrue)
            )
        )
}